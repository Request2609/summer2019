#include "Process.h"

//获取请求头
int process :: requestHeader(channel* chl) {
    Buffer* bf =chl->getReadBuffer() ;
    //解析请求行
    int readIndex = bf->getReadIndex() ;
    int writeIndex = bf->getWriteIndex() ;
    string a = bf->readBuffer(readIndex, writeIndex) ;
    int end = a.find("\r\n\r\n") ;
    //将信息获取完成，再解析
    //解析请求头
    int index = 0 ;
    string tmp ;
    int e = a.find("\r\n");
    //修改相应的结束标识
    a[e] = '\n' ;
    tmp = a.substr(index, e) ;
    index = e+2;
    int ret = getMethod(tmp) ;
    //如果是GET方法，解析路径名
    if(ret == GET) {
        int ret = messageSend(tmp, chl) ;
        return GET ;
    }

    //如果是post请求，找出content_length
    if(ret == POST) {
        return POST ;
    }
    if(ret == DEFAULT) {
        return DEFAULT ;
    }
    return 0  ;  
}   

string  process :: sendResponseHead(channel* chl, string type, long len, int statusCode, string tip) {
     //发送响应头
    char buf[1024] ;
    //构造响应头
    string head ;
    sprintf(buf, "%s %d %s\r\nContent_Type: %s\r\nContent_Length:%ld\r\n\r\n",
            version.c_str(), statusCode, tip.c_str(), type.c_str(),len) ;
    //将信息存入输入缓冲区中
    //
}   
//处理get请求，发送响应头和
int process :: messageSend(const string& tmp, channel* chl) {
    //找出现第一个空格的地方
    getVersionPath(tmp) ;
    //构造响应头
    //解析路径名
    //如果路径只包含“/”，发送初始化页面
    if(paths == "/") {
        struct stat st ;
        
        int ret = stat("test.html", &st) ;
        if(ret < 0) {
            cout << __FILE__ << __LINE__ << endl ;
            return -1 ;
        }
        //获取文件的大小
        long len = st.st_size ;
        sendResponseHead(chl, "text/html", len, 200, "OK") ;
    }
    //获取资源类型,资源长度，状态码，提示语
    int ret = isExist() ;
    if(ret == -1) { 
        return -1 ;
    }
    getResponseHead() ;
    return 1 ;
}
//资源是否存在
int process :: isExist() {
    if(access(paths.c_str(), F_OK) != -1) {
        return 1 ;
    }
    else {
        
    }
}
//获取版本号和请求路径
int process :: getVersionPath(string tmp) {
    
    int pathIndex = tmp.find(' ') ;
    pathIndex += 1 ;
    while(tmp[pathIndex] != ' ') {
        paths += tmp[pathIndex] ;
        pathIndex++ ;
    }
    pathIndex++ ;
    while(pathIndex < (int)tmp.length()) {
        version += tmp[pathIndex] ;
        pathIndex ++ ;
    }
    return 1 ;   
}

//获取请求体
int process :: requestBody(channel* channel_) {
    
    return 1 ;
}

int process :: getMethod(string& line) {
    if((int)line.find("GET") != -1) {
        method = GET ;
        return GET ;
    }
    else if((int)line.find("POST") != -1) {
        method = POST ;
        return POST ;           
    }
    else {
        method = DEFAULT ;
        return DEFAULT ;
    }
}   
